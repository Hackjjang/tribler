import logging
from typing import Optional, Set

from ipv8.taskmanager import TaskManager

from pony.orm import db_session

import tribler_core.components.metadata_store.db.orm_bindings.torrent_metadata as torrent_metadata
import tribler_core.components.metadata_store.db.store as MDS
from tribler_core.components.metadata_store.db.serialization import REGULAR_TORRENT
from tribler_core.components.tag.community.tag_payload import TagOperation, TagOperationEnum
from tribler_core.components.tag.db.tag_db import (
    CLOCK_FOR_AUTOGENERATED_TAGS,
    PUBLIC_KEY_FOR_AUTO_GENERATED_TAGS,
    TagDatabase,
)
from tribler_core.components.tag.rules.tag_rules import extract_only_valid_tags
from tribler_core.notifier import Notifier

LAST_PROCESSED_TORRENT_ID = 'last_processed_torrent_id'


class TagRulesProcessor(TaskManager):
    # this value must be incremented in the case of new rules set has been applied
    version: int = 1

    def __init__(self, notifier: Notifier, db: TagDatabase, mds: MDS.MetadataStore,
                 batch_size: int = 1000, interval: float = 10):
        """
        Default values for batch_size and interval are chosen so that tag processing is not too heavy
        fot CPU and with this values 360k items will be processed within the hour.
        """
        super().__init__()
        self.logger = logging.getLogger(self.__class__.__name__)

        self.notifier = notifier
        self.db = db
        self.mds = mds
        self.batch_size = batch_size
        self.interval = interval
        self.notifier.add_observer(torrent_metadata.NEW_TORRENT_METADATA_CREATED,
                                   callback=self.process_torrent_title)
        self.register_task(name=self.process_batch.__name__,
                           interval=interval,
                           task=self.process_batch)

    @db_session
    def process_batch(self) -> int:
        def query(_start, _end):
            return lambda t: _start < t.rowid and t.rowid <= _end and \
                             t.metadata_type == REGULAR_TORRENT and \
                             t.tag_version < self.version

        start = int(self.mds.get_value(LAST_PROCESSED_TORRENT_ID, default='0'))
        end = start + self.batch_size
        self.logger.info(f'Processing batch [{start}...{end}]')

        batch = self.mds.TorrentMetadata.select(query(start, end))
        processed = 0
        added = 0
        for torrent in batch:
            added += self.process_torrent_title(torrent.infohash, torrent.title)
            torrent.tag_version = self.version
            processed += 1

        self.logger.info(f'Processed: {processed} titles. Added {added} tags.')
        max_row_id = self.mds.get_max_rowid()

        is_beyond_the_boundary = end > max_row_id
        if is_beyond_the_boundary:
            self._schedule_new_process_batch_round()
        else:
            self.mds.set_value(LAST_PROCESSED_TORRENT_ID, str(end))
        return processed

    def process_torrent_title(self, infohash: Optional[bytes] = None, title: Optional[str] = None) -> int:
        if not infohash or not title:
            return 0
        tags = set(extract_only_valid_tags(title))
        if tags:
            self.save_tags(infohash, tags)
        return len(tags)

    @db_session
    def save_tags(self, infohash: bytes, tags: Set[str]):
        self.logger.debug(f'Save: {len(tags)} tags')
        for tag in tags:
            operation = TagOperation(
                infohash=infohash,
                operation=TagOperationEnum.ADD,
                clock=CLOCK_FOR_AUTOGENERATED_TAGS,
                creator_public_key=PUBLIC_KEY_FOR_AUTO_GENERATED_TAGS,
                tag=tag
            )
            # we want auto generated operation to act like a normal operation
            # therefore we use 2 as a `counter_increment` to immediately pass
            # SHOW_THRESHOLD
            self.db.add_auto_generated_tag_operation(operation=operation)

    def _schedule_new_process_batch_round(self):
        self.logger.info('All items in TorrentMetadata have been processed.')
        self.mds.set_value(LAST_PROCESSED_TORRENT_ID, '0')
        self.logger.info('Set last_processed_torrent_id to 0')
        self.interval *= 2
        self.logger.info(f'Double the interval. New interval: {self.interval}')
        self.batch_size *= 2
        self.logger.info(f'Double the batch size. New batch size: {self.batch_size}')
        self.replace_task(self.process_batch.__name__,
                          interval=self.interval,
                          task=self.process_batch)
